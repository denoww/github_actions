# rodar_comandos_em_todos_ec2_com_tag.yml
name: comando SSM no EC2

on:
  workflow_call:
    inputs:
      aws_region:
        type: string
        default: us-east-1
      ec2_com_tag:
        description: "Token a procurar dentro da tag 'projetos' (CSV-aware)"
        type: string
        required: true
      tag_key:
        description: "Chave da tag usada no filtro"
        type: string
        default: projetos
      remote_cmd:
        description: "Comando shell completo a executar nas instâncias"
        type: string
        required: true
      max_attempts:
        description: "Tentativas para aguardar conclusão do SSM"
        type: number
        default: 60
      interval_secs:
        description: "Intervalo (s) entre tentativas"
        type: number
        default: 5
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true

jobs:
  comando_ssm_no_ec2:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Descobrir instâncias alvo (tag CSV-aware)
        id: discover
        shell: bash
        env:
          AWS_REGION: ${{ inputs.aws_region }}
          TAG_KEY: ${{ inputs.tag_key }}
          PROJECT_TOKEN: ${{ inputs.ec2_com_tag }}
        run: |
          set -euo pipefail
          aws ec2 describe-instances \
            --region "$AWS_REGION" \
            --filters Name=instance-state-name,Values=running Name=tag-key,Values="$TAG_KEY" \
            --query 'Reservations[].Instances[].[InstanceId,Tags]' \
            --output json > instances.json

          ids=$(jq -r --arg tok "$PROJECT_TOKEN" --arg key "$TAG_KEY" '
            .[] 
            | {id: .[0], tags: (.[1] // [])}
            | (.tags[]? | select(.Key==$key) | .Value // "" | gsub("\\s";"")) as $val
            | select($val | test("(^|,)" + $tok + "(,|$)"))
            | .id
          ' instances.json | sort -u | tr '\n' ' ')

          echo "Targets: ${ids:-<none>}"
          echo "instance_ids=${ids}" >> "$GITHUB_OUTPUT"

      - name: Executar via SSM
        if: steps.discover.outputs.instance_ids != ''
        shell: bash
        env:
          AWS_REGION:   ${{ inputs.aws_region }}
          INSTANCE_IDS: ${{ steps.discover.outputs.instance_ids }}
          REMOTE_CMD:   ${{ inputs.remote_cmd }}
          MAX_ATTEMPTS: ${{ inputs.max_attempts }}
          INTERVAL:     ${{ inputs.interval_secs }}
        run: |
          set -euo pipefail

          : "${MAX_ATTEMPTS:=60}"
          : "${INTERVAL:=5}"
          [[ "$MAX_ATTEMPTS" =~ ^[0-9]+$ ]] || MAX_ATTEMPTS=60
          [[ "$INTERVAL" =~ ^[0-9]+$ ]] || INTERVAL=5
          echo "MAX_ATTEMPTS=$MAX_ATTEMPTS INTERVAL=$INTERVAL"

          FAIL=0

          for ID in $INSTANCE_IDS; do
            echo "::group::Enviando comando para $ID"

            # JSON seguro para --parameters
            PARAMS=$(jq -Rn --arg cmd "$REMOTE_CMD" '{commands: [$cmd]}')

            COMMAND_ID=$(aws ssm send-command \
              --region "$AWS_REGION" \
              --document-name "AWS-RunShellScript" \
              --comment "GitHub Actions EC2 comando_ssm_no_ec2" \
              --parameters "$PARAMS" \
              --instance-ids "$ID" \
              --query 'Command.CommandId' --output text)

            echo "CommandId: $COMMAND_ID"

            #####################################################
            #####################################################
            #####################################################
            GCI=$(aws ssm get-command-invocation \
              --region "$AWS_REGION" \
              --command-id "$COMMAND_ID" \
              --instance-id "$ID" \
              --output json || true)

            FINAL_STATUS=$(jq -r '.Status // "Unknown"' <<<"$GCI")
            PLUGIN_STATUS="$FINAL_STATUS"  # quando há 1 plugin, status do comando = do plugin
            RESPONSE_CODE=$(jq -r '.ResponseCode // empty' <<<"$GCI")
            STDOUT=$(jq -r '.StandardOutputContent // ""' <<<"$GCI")
            STDERR=$(jq -r '.StandardErrorContent  // ""' <<<"$GCI")

            # normaliza response code vazio quando sucesso
            if [[ -z "${RESPONSE_CODE}" || "${RESPONSE_CODE}" == "null" ]]; then
              if [[ "$FINAL_STATUS" == "Success" ]]; then RESPONSE_CODE=0; else RESPONSE_CODE=-1; fi
            fi

            echo "FinalStatus=$FINAL_STATUS PluginStatus=$PLUGIN_STATUS ResponseCode=$RESPONSE_CODE"
            echo "--- STDOUT ---"
            printf "%s\n" "$STDOUT"
            echo "--- STDERR ---"
            printf "%s\n" "$STDERR"
            #####################################################
            #####################################################

            # attempt=0
            # while (( attempt < MAX_ATTEMPTS )); do
            #   STATUS=$(aws ssm get-command-invocation \
            #     --region "$AWS_REGION" \
            #     --command-id "$COMMAND_ID" \
            #     --instance-id "$ID" \
            #     --query 'Status' --output text 2>/dev/null || echo "Pending")
            #   echo "[$ID] Status: $STATUS"
            #   case "$STATUS" in
            #     Success|Cancelled|TimedOut|Failed) break ;;
            #   esac
            #   sleep "$INTERVAL"
            #   attempt=$((attempt+1))
            # done

            # # Pega DETALHES por plugin (mais confiável que o agregado)
            # aws ssm list-command-invocations \
            #   --region "$AWS_REGION" \
            #   --command-id "$COMMAND_ID" \
            #   --instance-id "$ID" \
            #   --details \
            #   --output json > ssm_out.json || true

            # FINAL_STATUS=$(jq -r '.CommandInvocations[0].Status // "Unknown"' ssm_out.json 2>/dev/null || echo "Unknown")
            # PLUGIN_STATUS=$(jq -r '.CommandInvocations[0].CommandPlugins[] | select(.Name=="aws:runShellScript") | .Status' ssm_out.json 2>/dev/null | tail -n1 || echo "")
            # RESPONSE_CODE=$(jq -r '.CommandInvocations[0].CommandPlugins[] | select(.Name=="aws:runShellScript") | .ResponseCode' ssm_out.json 2>/dev/null | tail -n1 || echo "")
            # STDOUT=$(jq -r '.CommandInvocations[0].CommandPlugins[] | select(.Name=="aws:runShellScript") | .Output' ssm_out.json 2>/dev/null | tail -n1 || echo "")
            # STDERR=$(jq -r '.CommandInvocations[0].CommandPlugins[] | select(.Name=="aws:runShellScript") | .StandardErrorUrl' ssm_out.json 2>/dev/null | tail -n1 || echo "")

            # # Trata ResponseCode nulo quando o status foi Success
            # if [[ -z "${RESPONSE_CODE}" || "${RESPONSE_CODE}" == "null" ]]; then
            #   if [[ "$FINAL_STATUS" == "Success" || "$PLUGIN_STATUS" == "Success" ]]; then
            #     RESPONSE_CODE=0
            #   else
            #     RESPONSE_CODE=-1
            #   fi
            # fi

            # echo "FinalStatus=$FINAL_STATUS PluginStatus=$PLUGIN_STATUS ResponseCode=$RESPONSE_CODE"
            # echo "--- STDOUT ---"
            # echo "$STDOUT"
            # echo "--- STDERR URL (se houver) ---"
            # echo "$STDERR"




            # Só falha em casos reais
            if [[ "$FINAL_STATUS" == "Failed" || "$FINAL_STATUS" == "TimedOut" || "$FINAL_STATUS" == "Cancelled" ]]; then
              echo "::error title=SSM falhou para $ID::Status=$FINAL_STATUS"
              FAIL=1
            elif [[ "$PLUGIN_STATUS" == "Failed" || "$PLUGIN_STATUS" == "TimedOut" || "$PLUGIN_STATUS" == "Cancelled" ]]; then
              echo "::error title=Plugin aws:runShellScript falhou para $ID::PluginStatus=$PLUGIN_STATUS"
              FAIL=1
            elif [[ "$RESPONSE_CODE" != "0" ]]; then
              echo "::error title=Comando retornou código != 0 para $ID::ResponseCode=$RESPONSE_CODE"
              FAIL=1
            fi

            echo "::endgroup::"
          done

          exit $FAIL


      - name: Sem alvos compatíveis
        if: steps.discover.outputs.instance_ids == ''
        run: echo "Nenhuma instância com tag '${{ inputs.tag_key }}' contendo '${{ inputs.ec2_com_tag }}'."
