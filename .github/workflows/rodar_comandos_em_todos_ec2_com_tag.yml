name: Reusable • EC2 fanout via SSM

on:
  workflow_call:
    inputs:
      aws_region:
        type: string
        default: us-east-1
      ec2_com_tag:
        description: "Token a procurar dentro da tag 'projetos' (CSV-aware)"
        type: string
        required: true
      tag_key:
        description: "Chave da tag usada no filtro"
        type: string
        default: projetos
      remote_cmd:
        description: "Comando shell completo a executar nas instâncias"
        type: string
        required: true
      max_attempts:
        description: "Tentativas para aguardar conclusão do SSM"
        type: number
        default: 60
      interval_secs:
        description: "Intervalo (s) entre tentativas"
        type: number
        default: 5
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true

jobs:
  fanout:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Descobrir instâncias alvo (tag CSV-aware)
        id: discover
        shell: bash
        env:
          AWS_REGION: ${{ inputs.aws_region }}
          TAG_KEY: ${{ inputs.tag_key }}
          PROJECT_TOKEN: ${{ inputs.ec2_com_tag }}
        run: |
          set -euo pipefail
          aws ec2 describe-instances \
            --region "$AWS_REGION" \
            --filters Name=instance-state-name,Values=running Name=tag-key,Values="$TAG_KEY" \
            --query 'Reservations[].Instances[].[InstanceId,Tags]' \
            --output json > instances.json

          ids=$(jq -r --arg tok "$PROJECT_TOKEN" --arg key "$TAG_KEY" '
            .[] 
            | {id: .[0], tags: (.[1] // [])}
            | (.tags[]? | select(.Key==$key) | .Value // "" | gsub("\\s";"")) as $val
            | select($val | test("(^|,)" + $tok + "(,|$)"))
            | .id
          ' instances.json | sort -u | tr '\n' ' ')

          echo "Targets: ${ids:-<none>}"
          echo "instance_ids=${ids}" >> "$GITHUB_OUTPUT"


      - name: Executar via SSM
              if: steps.discover.outputs.instance_ids != ''
              shell: bash
              env:
                AWS_REGION:   ${{ inputs.aws_region }}
                INSTANCE_IDS: ${{ steps.discover.outputs.instance_ids }}
                REMOTE_CMD:   ${{ inputs.remote_cmd }}
                MAX_ATTEMPTS: ${{ inputs.max_attempts }}
                INTERVAL:     ${{ inputs.interval_secs }}
              run: |
                set -euo pipefail

                # Defaults defensivos (não confie que inputs.* sempre chega)
                : "${MAX_ATTEMPTS:=60}"
                : "${INTERVAL:=5}"
                [[ "$MAX_ATTEMPTS" =~ ^[0-9]+$ ]] || MAX_ATTEMPTS=60
                [[ "$INTERVAL" =~ ^[0-9]+$ ]] || INTERVAL=5
                echo "MAX_ATTEMPTS=$MAX_ATTEMPTS INTERVAL=$INTERVAL"

                FAIL=0

                for ID in $INSTANCE_IDS; do
                  echo "::group::Enviando comando para $ID"

                  # Monta JSON seguro pro --parameters
                  PARAMS=$(jq -Rn --arg cmd "$REMOTE_CMD" '{commands: [$cmd]}')

                  COMMAND_ID=$(aws ssm send-command \
                    --region "$AWS_REGION" \
                    --document-name "AWS-RunShellScript" \
                    --comment "GitHub Actions EC2 fanout" \
                    --parameters "$PARAMS" \
                    --instance-ids "$ID" \
                    --query 'Command.CommandId' --output text)

                  echo "CommandId: $COMMAND_ID"

                  attempt=0
                  STATUS="Pending"
                  while (( attempt < MAX_ATTEMPTS )); do
                    STATUS=$(aws ssm get-command-invocation \
                      --region "$AWS_REGION" \
                      --command-id "$COMMAND_ID" \
                      --instance-id "$ID" \
                      --query 'Status' --output text \
                      || echo "Pending")
                    echo "[$ID] Status: $STATUS"
                    case "$STATUS" in
                      Success|Cancelled|TimedOut|Failed) break ;;
                    esac
                    sleep "$INTERVAL"
                    ((attempt++))
                  done

                  # Captura saída e códigos finais
                  aws ssm get-command-invocation \
                    --region "$AWS_REGION" \
                    --command-id "$COMMAND_ID" \
                    --instance-id "$ID" \
                    --output json > ssm_out.json || true

                  FINAL_STATUS=$(jq -r '.Status // "Unknown"' ssm_out.json 2>/dev/null || echo "Unknown")
                  RESPONSE_CODE=$(jq -r '.ResponseCode // -1' ssm_out.json 2>/dev/null || echo -1)

                  echo "FinalStatus=$FINAL_STATUS ResponseCode=$RESPONSE_CODE"
                  echo "--- STDOUT ---"; jq -r '.StandardOutputContent // ""' ssm_out.json
                  echo "--- STDERR ---"; jq -r '.StandardErrorContent // ""' ssm_out.json

                  if [[ "$FINAL_STATUS" != "Success" ]] || [[ "$RESPONSE_CODE" != "0" ]]; then
                    echo "::error title=SSM falhou para $ID::Status=$FINAL_STATUS ResponseCode=$RESPONSE_CODE"
                    FAIL=1
                  fi

                  echo "::endgroup::"
                done

                exit $FAIL

      - name: Sem alvos compatíveis
        if: steps.discover.outputs.instance_ids == ''
        run: echo "Nenhuma instância com tag '${{ inputs.tag_key }}' contendo '${{ inputs.ec2_com_tag }}'."
