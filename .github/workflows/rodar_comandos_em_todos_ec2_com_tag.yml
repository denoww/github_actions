# rodar_comandos_em_todos_ec2_com_tag.yml
name: comando SSM no EC2

on:
  workflow_call:
    inputs:
      aws_region:
        type: string
        default: us-east-1
      ec2_com_tag:
        description: "Token a procurar dentro da tag 'projetos' (CSV-aware)"
        type: string
        required: true
      tag_key:
        description: "Chave da tag usada no filtro"
        type: string
        default: projetos
      remote_cmd:
        description: "Comando shell completo a executar nas instâncias"
        type: string
        required: true
      max_attempts:
        description: "Tentativas para aguardar conclusão do SSM"
        type: number
        default: 60
      interval_secs:
        description: "Intervalo (s) entre tentativas"
        type: number
        default: 5
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true

jobs:
  comando_ssm_no_ec2:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Descobrir instâncias alvo (tag CSV-aware)
        id: discover
        shell: bash
        env:
          AWS_REGION: ${{ inputs.aws_region }}
          TAG_KEY: ${{ inputs.tag_key }}
          PROJECT_TOKEN: ${{ inputs.ec2_com_tag }}
        run: |
          set -euo pipefail
          aws ec2 describe-instances \
            --region "$AWS_REGION" \
            --filters Name=instance-state-name,Values=running Name=tag-key,Values="$TAG_KEY" \
            --query 'Reservations[].Instances[].[InstanceId,Tags]' \
            --output json > instances.json

          ids=$(jq -r --arg tok "$PROJECT_TOKEN" --arg key "$TAG_KEY" '
            .[] 
            | {id: .[0], tags: (.[1] // [])}
            | (.tags[]? | select(.Key==$key) | .Value // "" | gsub("\\s";"")) as $val
            | select($val | test("(^|,)" + $tok + "(,|$)"))
            | .id
          ' instances.json | sort -u | tr '\n' ' ')

          echo "Targets: ${ids:-<none>}"
          echo "instance_ids=${ids}" >> "$GITHUB_OUTPUT"

      - name: Executar via SSM
        if: steps.discover.outputs.instance_ids != ''
        shell: bash
        env:
          AWS_REGION:   ${{ inputs.aws_region }}
          INSTANCE_IDS: ${{ steps.discover.outputs.instance_ids }}
          REMOTE_CMD:   ${{ inputs.remote_cmd }}
          MAX_ATTEMPTS: ${{ inputs.max_attempts }}
          INTERVAL:     ${{ inputs.interval_secs }}
        run: |
          set -euo pipefail

          : "${MAX_ATTEMPTS:=60}"
          : "${INTERVAL:=5}"
          [[ "$MAX_ATTEMPTS" =~ ^[0-9]+$ ]] || MAX_ATTEMPTS=60
          [[ "$INTERVAL" =~ ^[0-9]+$ ]] || INTERVAL=5
          echo "MAX_ATTEMPTS=$MAX_ATTEMPTS INTERVAL=$INTERVAL"

          # 1) Codifica o comando remoto para evitar problemas de quoting
          REMOTE_CMD_B64="$(printf '%s' "$REMOTE_CMD" | base64 -w0)"  # GNU coreutils no ubuntu-latest

          FAIL=0
          for ID in $INSTANCE_IDS; do
            echo "::group::Enviando comando para $ID"

            # 2) Wrapper que:
            #   - habilita set -euxo pipefail
            #   - grava tudo em /tmp/ga_cmd.out
            #   - decodifica o script do usuário (base64) para /tmp/ga_cmd.sh
            #   - executa e imprime as últimas 1000 linhas do log
            #   - retorna o mesmo exit code
            read -r -d '' WRAPPED_CMD <<'EOS'
          set -euxo pipefail
          LOG=/tmp/ga_cmd.out

          # escreve o script do usuário a partir de base64
          : "${REMOTE_CMD_B64:?missing}"
          printf '%s' "$REMOTE_CMD_B64" | base64 -d >/tmp/ga_cmd.sh

          # garante permissões e ambiente
          chmod +x /tmp/ga_cmd.sh
          export HOME="${HOME:-/root}"

          # executa capturando stdout+stderr no arquivo
          bash -lc "bash /tmp/ga_cmd.sh" >"$LOG" 2>&1 || RC=$? || true
          RC="${RC:-0}"

          echo "--- BEGIN REMOTE LOG ---"
          tail -n 1000 "$LOG" || true
          echo "--- END REMOTE LOG ---"
          echo "EXIT_CODE=$RC"
          exit "$RC"
          EOS

            # 3) Injeta o REMOTE_CMD_B64 no wrapper sem sed, usando variável de ambiente
            #    Vamos montar um comando único que exporta REMOTE_CMD_B64 e roda o wrapper.
            FULL_CMD="export REMOTE_CMD_B64='$REMOTE_CMD_B64'; $WRAPPED_CMD"

            # 4) Parâmetros do SSM (JSON seguro)
            PARAMS="$(jq -Rn --arg cmd "$FULL_CMD" '{commands: [$cmd]}')"

            # 5) Envia o comando
            COMMAND_ID=$(aws ssm send-command \
              --region "$AWS_REGION" \
              --document-name "AWS-RunShellScript" \
              --comment "GitHub Actions EC2 comando_ssm_no_ec2" \
              --parameters "$PARAMS" \
              --instance-ids "$ID" \
              --query 'Command.CommandId' --output text)

            echo "CommandId: $COMMAND_ID"

            # 6) Espera conclusão
            attempt=0
            while (( attempt < MAX_ATTEMPTS )); do
              STATUS=$(aws ssm get-command-invocation \
                --region "$AWS_REGION" \
                --command-id "$COMMAND_ID" \
                --instance-id "$ID" \
                --query 'Status' --output text 2>/dev/null || echo "Pending")
              echo "[$ID] Status: $STATUS"
              case "$STATUS" in
                Success|Cancelled|TimedOut|Failed) break ;;
              esac
              sleep "$INTERVAL"
              attempt=$((attempt+1))
            done

            # 7) Busca conteúdo final (até ~24KB por campo – suficiente com nosso tail)
            GCI=$(aws ssm get-command-invocation \
              --region "$AWS_REGION" \
              --command-id "$COMMAND_ID" \
              --instance-id "$ID" \
              --output json || true)

            FINAL_STATUS=$(jq -r '.Status // "Unknown"' <<<"$GCI")
            RESPONSE_CODE=$(jq -r '.ResponseCode // empty' <<<"$GCI")
            STDOUT=$(jq -r '.StandardOutputContent // ""' <<<"$GCI")
            STDERR=$(jq -r '.StandardErrorContent  // ""' <<<"$GCI")

            # normaliza response code vazio quando sucesso
            if [[ -z "${RESPONSE_CODE}" || "${RESPONSE_CODE}" == "null" ]]; then
              if [[ "$FINAL_STATUS" == "Success" ]]; then RESPONSE_CODE=0; else RESPONSE_CODE=-1; fi
            fi

            echo "FinalStatus=$FINAL_STATUS ResponseCode=$RESPONSE_CODE"
            echo "--- STDOUT ---"; printf "%s\n" "$STDOUT"
            echo "--- STDERR ---"; printf "%s\n" "$STDERR"

            if [[ "$FINAL_STATUS" == "Failed" || "$FINAL_STATUS" == "TimedOut" || "$FINAL_STATUS" == "Cancelled" || "$RESPONSE_CODE" != "0" ]]; then
              echo "::error title=SSM falhou para $ID::Status=$FINAL_STATUS ResponseCode=$RESPONSE_CODE"
              FAIL=1
            fi

            echo "::endgroup::"
          done

          exit $FAIL


          # set -euo pipefail

          # : "${MAX_ATTEMPTS:=60}"
          # : "${INTERVAL:=5}"
          # [[ "$MAX_ATTEMPTS" =~ ^[0-9]+$ ]] || MAX_ATTEMPTS=60
          # [[ "$INTERVAL" =~ ^[0-9]+$ ]] || INTERVAL=5
          # echo "MAX_ATTEMPTS=$MAX_ATTEMPTS INTERVAL=$INTERVAL"

          # FAIL=0

          # for ID in $INSTANCE_IDS; do
          #   echo "::group::Enviando comando para $ID"

          #   # JSON seguro para --parameters
          #   PARAMS=$(jq -Rn --arg cmd "$REMOTE_CMD" '{commands: [$cmd]}')

          #   COMMAND_ID=$(aws ssm send-command \
          #     --region "$AWS_REGION" \
          #     --document-name "AWS-RunShellScript" \
          #     --comment "GitHub Actions EC2 comando_ssm_no_ec2" \
          #     --parameters "$PARAMS" \
          #     --instance-ids "$ID" \
          #     --query 'Command.CommandId' --output text)

          #   echo "CommandId: $COMMAND_ID"

          #   #####################################################
          #   #####################################################
          #   #####################################################
          #   # GCI=$(aws ssm get-command-invocation \
          #   #   --region "$AWS_REGION" \
          #   #   --command-id "$COMMAND_ID" \
          #   #   --instance-id "$ID" \
          #   #   --output json || true)

          #   # FINAL_STATUS=$(jq -r '.Status // "Unknown"' <<<"$GCI")
          #   # PLUGIN_STATUS="$FINAL_STATUS"  # quando há 1 plugin, status do comando = do plugin
          #   # RESPONSE_CODE=$(jq -r '.ResponseCode // empty' <<<"$GCI")
          #   # STDOUT=$(jq -r '.StandardOutputContent // ""' <<<"$GCI")
          #   # STDERR=$(jq -r '.StandardErrorContent  // ""' <<<"$GCI")

          #   # # normaliza response code vazio quando sucesso
          #   # if [[ -z "${RESPONSE_CODE}" || "${RESPONSE_CODE}" == "null" ]]; then
          #   #   if [[ "$FINAL_STATUS" == "Success" ]]; then RESPONSE_CODE=0; else RESPONSE_CODE=-1; fi
          #   # fi

          #   # echo "FinalStatus=$FINAL_STATUS PluginStatus=$PLUGIN_STATUS ResponseCode=$RESPONSE_CODE"
          #   # echo "--- STDOUT ---"
          #   # printf "%s\n" "$STDOUT"
          #   # echo "--- STDERR ---"
          #   # printf "%s\n" "$STDERR"
          #   #####################################################
          #   #####################################################

          #   attempt=0
          #   while (( attempt < MAX_ATTEMPTS )); do
          #     STATUS=$(aws ssm get-command-invocation \
          #       --region "$AWS_REGION" \
          #       --command-id "$COMMAND_ID" \
          #       --instance-id "$ID" \
          #       --query 'Status' --output text 2>/dev/null || echo "Pending")
          #     echo "[$ID] Status: $STATUS"
          #     case "$STATUS" in
          #       Success|Cancelled|TimedOut|Failed) break ;;
          #     esac
          #     sleep "$INTERVAL"
          #     attempt=$((attempt+1))
          #   done

          #   # Pega DETALHES por plugin (mais confiável que o agregado)
          #   aws ssm list-command-invocations \
          #     --region "$AWS_REGION" \
          #     --command-id "$COMMAND_ID" \
          #     --instance-id "$ID" \
          #     --details \
          #     --output json > ssm_out.json || true

          #   FINAL_STATUS=$(jq -r '.CommandInvocations[0].Status // "Unknown"' ssm_out.json 2>/dev/null || echo "Unknown")
          #   PLUGIN_STATUS=$(jq -r '.CommandInvocations[0].CommandPlugins[] | select(.Name=="aws:runShellScript") | .Status' ssm_out.json 2>/dev/null | tail -n1 || echo "")
          #   RESPONSE_CODE=$(jq -r '.CommandInvocations[0].CommandPlugins[] | select(.Name=="aws:runShellScript") | .ResponseCode' ssm_out.json 2>/dev/null | tail -n1 || echo "")
          #   STDOUT=$(jq -r '.CommandInvocations[0].CommandPlugins[] | select(.Name=="aws:runShellScript") | .Output' ssm_out.json 2>/dev/null | tail -n1 || echo "")
          #   STDERR=$(jq -r '.CommandInvocations[0].CommandPlugins[] | select(.Name=="aws:runShellScript") | .StandardErrorUrl' ssm_out.json 2>/dev/null | tail -n1 || echo "")

          #   # Trata ResponseCode nulo quando o status foi Success
          #   if [[ -z "${RESPONSE_CODE}" || "${RESPONSE_CODE}" == "null" ]]; then
          #     if [[ "$FINAL_STATUS" == "Success" || "$PLUGIN_STATUS" == "Success" ]]; then
          #       RESPONSE_CODE=0
          #     else
          #       RESPONSE_CODE=-1
          #     fi
          #   fi

          #   echo "FinalStatus=$FINAL_STATUS PluginStatus=$PLUGIN_STATUS ResponseCode=$RESPONSE_CODE"
          #   echo "--- STDOUT ---"
          #   echo "$STDOUT"
          #   echo "--- STDERR URL (se houver) ---"
          #   echo "$STDERR"




          #   # Só falha em casos reais
          #   if [[ "$FINAL_STATUS" == "Failed" || "$FINAL_STATUS" == "TimedOut" || "$FINAL_STATUS" == "Cancelled" ]]; then
          #     echo "::error title=SSM falhou para $ID::Status=$FINAL_STATUS"
          #     FAIL=1
          #   elif [[ "$PLUGIN_STATUS" == "Failed" || "$PLUGIN_STATUS" == "TimedOut" || "$PLUGIN_STATUS" == "Cancelled" ]]; then
          #     echo "::error title=Plugin aws:runShellScript falhou para $ID::PluginStatus=$PLUGIN_STATUS"
          #     FAIL=1
          #   elif [[ "$RESPONSE_CODE" != "0" ]]; then
          #     echo "::error title=Comando retornou código != 0 para $ID::ResponseCode=$RESPONSE_CODE"
          #     FAIL=1
          #   fi

          #   echo "::endgroup::"
          # done

          # exit $FAIL


      - name: Sem alvos compatíveis
        if: steps.discover.outputs.instance_ids == ''
        run: echo "Nenhuma instância com tag '${{ inputs.tag_key }}' contendo '${{ inputs.ec2_com_tag }}'."
